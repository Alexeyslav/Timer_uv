


LED_SET_REG: ; Загрузка содержимого ACCUM в регистр сегментов.

 led_latch_1 ; Подготовка к защелкиванию
 LDI tempi, 7
 sl_loop: ; Цикл побитно - 8 раз.
  led_serial_0	; Предполагаем следующий бит для загрузки равен нулю
  led_clock_0	; Подготовка к такту
 ROL ACCUM		;Старшим разрядом вперьооод
 BRCC sl_bit_zero 
 led_serial_1 ; ошиблись - бит равен 1
sl_bit_zero:
 led_clock_1 ; проталкиваем очередной бит в регистр
 dec tempi
 BRNE sl_loop

;led_serial - вход регистра
;led_clock фиксация с 0 на 1
;led_latch 0-1-0, защелка с 1 на 0 
 led_latch_0 ; Защелкивание загруженных данных в регистре
 
ret

LED_OFF: // Отключение всех разрядов, для безопасной смены сегментов.

IN tempi, PORTD
;ANDI tempi, ~led_digit_mask // маска с "0" на месте разрядов портов, остальные биты не трогаем!
CBR tempi, led_digit_mask // Обнулить биты регистра по маске
OUT PORTD, tempi
ret

LED_DIGIT_ENABLE: // Включение указанного в регистре ACCUM разряда индикатора
                  // Проверка на двойное включение не производится! 
				  // Использовать подпрограмму только после LED_OFF!!!

// Биты разрядов не лежат непрерывно и могут быть произвольно переназначены, 
// поэтому простым сдвигом не обойтись...

 ANDI ACCUM, 0x03 // Оставим только первые 2 бита: гарантируем значение 0..3
 BRNE LDE_dig1    // Проверка на первый разряд
  led_digit0_on   // Если число сразу стало нулем - значит выбран первый разряд, включем.
ret               // больше делать нечего - выходим. 
LDE_dig1: DEC ACCUM
 BRNE LDE_dig2    // Проверка на второй разряд
  led_digit1_on    
ret
LDE_dig2: DEC ACCUM
 BRNE LDE_dig3    // Проверка на третий разряд
  led_digit2_on    
ret
LDE_dig3:     // Если остальные проверки провалились - остается только четвертый разряд.
 led_digit3_on    
ret

conv_numtosegment:	// На входе ACCUM - номер символа 0..15, 
					// на выходе ACCUM - битовая маска сегментов соответствующая символу
					// для работы исползуется индексный регистр Z

 LDI ZH, high(segment_table*2)
 LDI ZL, low (segment_table*2)
 Add ZL, ACCUM
 BRCC PC+1	; если в результате перешли границу 256-байтной страницы, надо перейти на новую страницу
  INC ZH    ; пропустить команду если нет переполнения страницы. как-то так.

LPM 	ACCUM, Z

ret


segment_table:
.EQU led_segment_h = 0x80
//     HGFEDCBA
//.DB	0xb00111111, 0xb00000011  // 0, 1
//.DB	0xb01101101, 0xb01100111  // 2, 3
//.DB	0xb01010011, 0xb01110110  // 4, 5
//.DB	0xb01111110, 0xb00100011  // 6, 7
//.DB	0xb01111111, 0xb01110111  // 8, 9
//.DB	0xb01000000, 0xb11111111  // -, n/a
//.DB	0xb11111111, 0xb11111111  // n/a, n/a
//.DB	0xb11111111, 0xb11111111  // n/a, n/a
// Итить-колотить!!! Компилятор этим способом не понимает двоичные числа! Он тупо берет последние два символа числа и считает их 16-ричным числом, пофиг что оно записано в двоичной форме.

.DB	0x3F, 0x03  // 0, 1
.DB	0x6D, 0x67  // 2, 3
.DB	0x53, 0x76  // 4, 5
.DB	0x7E, 0x23  // 6, 7
.DB	0x7F, 0x77  // 8, 9
.DB	0x40, 0xFF  // -, n/a
.DB	0xFF, 0xFF  // n/a, n/a
.DB	0xFF, 0xFF  // n/a, n/a
